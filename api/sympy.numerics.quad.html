<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
        <html><head>
        <link rel="stylesheet" type="text/css" href="apidocs.css"/>
        <title>API docs for &ldquo;sympy.numerics.quad&rdquo;</title>
        </head>
        <body><h1 class="module">Module s.n.quad</h1><span id="part">Part of <a href="sympy.numerics.html">sympy.numerics</a></span><div class="toplevel"><div>Routines for arbitrary-precision numerical quadrature
</div></div><table class="children"><tr class="class"><td>Class</td><td><a href="sympy.numerics.quad.Quadrature.html">Quadrature</a></td><td><div>This class provides a standard interface for quadrature rules. A
</div></td></tr><tr class="class"><td>Class</td><td><a href="sympy.numerics.quad.Midpoint.html">Midpoint</a></td><td><span class="undocumented">Undocumented</span></td></tr><tr class="class"><td>Class</td><td><a href="sympy.numerics.quad.Trapezoid.html">Trapezoid</a></td><td><span class="undocumented">Undocumented</span></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.numerics.quad._iterfixpoint">_iterfixpoint</a></td><td><span class="undocumented">Undocumented</span></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.numerics.quad._gaussnode">_gaussnode</a></td><td><span class="undocumented">Undocumented</span></td></tr><tr class="class"><td>Class</td><td><a href="sympy.numerics.quad.GaussLegendre.html">GaussLegendre</a></td><td><div>Gauss-Legendre quadrature is highly efficient for smooth integrands
</div></td></tr><tr class="class"><td>Class</td><td><a href="sympy.numerics.quad.CompositeGaussLegendre.html">CompositeGaussLegendre</a></td><td><div>Gauss-Legendre quadrature with error estimation. Two Gauss-Legendre
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.numerics.quad._tsnode">_tsnode</a></td><td><span class="undocumented">Undocumented</span></td></tr><tr class="class"><td>Class</td><td><a href="sympy.numerics.quad.TanhSinh.html">TanhSinh</a></td><td><div>The tanh-sinh quadrature rule (also known as the doubly-exponential
</div></td></tr><tr class="class"><td>Class</td><td><a href="sympy.numerics.quad.AdaptiveTanhSinh.html">AdaptiveTanhSinh</a></td><td><div>Adaptive tanh-sinh quadrature algorithm.
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.numerics.quad.nintegrate">nintegrate</a></td><td><div>Basic usage
</div></td></tr></table>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.numerics.quad._iterfixpoint">_iterfixpoint(h, x, eps):</a></div>
            <div class="functionBody"><div class="undocumented">Undocumented</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.numerics.quad._gaussnode">_gaussnode(pf, k, n):</a></div>
            <div class="functionBody"><div class="undocumented">Undocumented</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.numerics.quad._tsnode">_tsnode(k, h):</a></div>
            <div class="functionBody"><div class="undocumented">Undocumented</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.numerics.quad.nintegrate">nintegrate(f, a, b, method=0, maxsteps=5000, verbose=False):</a></div>
            <div class="functionBody"><pre>Basic usage
===========

nintegrate(f, a, b) numerically evaluates the integral

       - b
      |    f(x) dx.
     -   a


The integrand f should be a callable that accepts a Float as input
and outputs a Float or ComplexFloat; a and b should be Floats,
numbers that can be converted to Floats, or +/- infinity.

A simple example:

    >>> Float.setdps(15)
    >>> print nintegrate(lambda x: 2*x**2 - 4*x, 2, 3)
    2.66666666666667

Calculating the area of a unit circle, with 30 digits:

    >>> Float.setdps(30)
    >>> print nintegrate(lambda x: 4*sqrt(1-x**2), 0, 1)
    3.14159265358979323846264338328

The integration interval can be infinite or semi-infinite:

    >>> Float.setdps(15)
    >>> print nintegrate(lambda x: exp(-x)*sin(x), 0, oo)
    0.5

Integration methods and accuracy
================================

Nintegrate attempts to obtain a value that is fully accurate within
the current working precision (i.e., correct to 15 decimal places
at the default precision level). If nintegrate fails to reach full
accuracy after a certain number of steps, it prints a warning
message.

This message signifies either that the integral is either divergent
or, if convergent, ill-behaved. It may still be possible to
evaluate an ill-behaved integral by increasing the 'maxsteps'
setting, changing the integration method, and/or manually
transforming the integrand.

Nintegrate currently supports the following integration methods:

    method = 0  :  Gaussian quadrature (default)
    method = 1  :  tanh-sinh quadrature

Gaussian quadrature is generally very efficient if the integration
interval is finite and the integrand is smooth on the entire range
(including the endpoints). It may fail if the integrand has many
discontinuities, is highly oscillatory, or possesses integrable
singularities.

The tanh-sinh algorithm is often better if the integration interval
is infinite or if singularities are present at the endpoints;
especially at very high precision levels. It does not perform well
if there are singularities between the endpoints or the integrand
is bumpy or oscillatory.

It may help to manually transform the integrand, e.g. changing
variables to remove singularities or breaking up the integration
interval so that singularities appear only at the endpoints.

The 'verbose' flag can be set to track the computation's progress.</pre></div>
            </div></body>
        