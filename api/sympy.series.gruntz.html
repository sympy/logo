<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
        <html><head>
        <link rel="stylesheet" type="text/css" href="apidocs.css"/>
        <title>API docs for &ldquo;sympy.series.gruntz&rdquo;</title>
        </head>
        <body><h1 class="module">Module s.s.gruntz</h1><span id="part">Part of <a href="sympy.series.html">sympy.series</a></span><div class="toplevel"><div><h1 class="heading">Limits</h1>
  <p>Implemented according to the PhD thesis 
  http://www.cybertester.com/data/gruntz.pdf, which contains very thorough 
  descriptions of the algorithm including many examples.  We summarize here
  the gist of it.</p>
  <p>All functions are sorted according to how rapidly varying they are at 
  infinity using the following rules. Any two functions f and g can be 
  compared using the properties of L:</p>
  <p>L=lim  log|f(x)| / log|g(x)|           (for x -&gt; oo)</p>
  <p>We define &gt;, &lt; ~ according to:</p>
<pre class="literalblock">
   1. f &gt; g .... L=+-oo

       we say that:
       - f is greater than any power of g
       - f is more rapidly varying than g
       - f goes to infinity/zero faster than g


   2. f &lt; g .... L=0

       we say that:
       - f is lower than any power of g

   3. f ~ g .... L!=0,+-oo

       we say that:
       - both f and g are bounded from above and below by suitable integral
         powers of the other
</pre>
<h1 class="heading">Examples</h1>
  <p>:</p>
<pre class="literalblock">
   2 &lt; x &lt; exp(x) &lt; exp(x**2) &lt; exp(exp(x))
   2 ~ 3 ~ -5
   x ~ x**2 ~ x**3 ~ 1/x ~ x**m ~ -x
   exp(x) ~ exp(-x) ~ exp(2x) ~ exp(x)**2 ~ exp(x+exp(-x))
   f ~ 1/f
</pre>
  <p>So we can divide all the functions into comparability classes (x and 
  x^2 belong to one class, exp(x) and exp(-x) belong to some other class). 
  In principle, we could compare any two functions, but in our algorithm, 
  we don't compare anything below the class 2~3~-5 (for example log(x) is 
  below this), so we set 2~3~-5 as the lowest comparability class.</p>
  <p>Given the function f, we find the list of most rapidly varying (mrv 
  set) subexpressions of it. This list belongs to the same comparability 
  class. Let's say it is {exp(x), exp(2x)}. Using the rule f ~ 1/f we find 
  an element &quot;w&quot; (either from the list or a new one) from the 
  same comparability class which goes to zero at infinity. In our example 
  we set w=exp(-x) (but we could also set w=exp(-2x) or w=exp(-3x) ...). We
  rewrite the mrv set using w, in our case {1/w,1/w^2}, and substitute it 
  into f. Then we expand f into a series in w:</p>
<pre class="literalblock">
   f = c0*w^e0 + c1*w^e1 + ... + O(w^en),        where e0&lt;e1&lt;...&lt;en, c0!=0
</pre>
  <p>but for x-&gt;oo, lim f = lim c0*w^e0, because all the other terms go 
  to zero, because w goes to zero faster than the ci and ei. So:</p>
<pre class="literalblock">
   for e0&gt;0, lim f = 0
   for e0&lt;0, lim f = +-oo   (the sign depends on the sign of c0)
   for e0=0, lim f = lim c0
</pre>
  <p>We need to recursively compute limits at several places of the 
  algorithm, but as is shown in the PhD thesis, it always finishes.</p>
  <p>Important functions from the implementation:</p>
  <p>compare(a,b,x) compares &quot;a&quot; and &quot;b&quot; by computing 
  the limit L. mrv(e,x) returns the list of most rapidly varying (mrv) 
  subexpressions of &quot;e&quot; rewrite(e,Omega,x,wsym) rewrites 
  &quot;e&quot; in terms of w leadterm(f,x) returns the lowest power term 
  in the series of f mrv_leadterm(e,x) returns the lead term (c0,e0) for e 
  limitinf(e,x) computes lim e  (for x-&gt;oo) limit(e,z,z0) computes any 
  limit by converting it to the case x-&gt;oo</p>
  <p>All the functions are really simple and straightforward except 
  rewrite(), which is the most difficult/complex part of the algorithm. 
  When the algorithm fails, the bugs are usually in the series expansion 
  (i.e. in SymPy) or in rewrite.</p>
  <p>This code is almost exact rewrite of the Maple code inside the Gruntz 
  thesis.</p>
</div></div><table class="children"><tr class="function"><td>Function</td><td><a href="#sympy.series.gruntz.debug">debug</a></td><td><div><p>Only for debugging purposes: prints a tree</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.gruntz.tree">tree</a></td><td><div><p>Only debugging purposes: prints a tree</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.gruntz.maketree">maketree</a></td><td><div><p>Only debugging purposes: prints a tree</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.gruntz.compare">compare</a></td><td><div><p>Returns &quot;&lt;&quot; if a&lt;b, &quot;=&quot; for a==b, 
&quot;&gt;&quot; for a&gt;b</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.gruntz.mrv">mrv</a></td><td><div><p>Returns a python set of  most rapidly varying (mrv) subexpressions of 
'e'</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.gruntz.mrv_max">mrv_max</a></td><td><div><p>Computes the maximum of two sets of expressions f and g, which</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.gruntz.rewrite">rewrite</a></td><td><div><p>e(x) ... the function</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.gruntz.sign">sign</a></td><td><div><p>Returns a sign of an expression e(x) for x-&gt;oo.</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.gruntz.limitinf">limitinf</a></td><td><div><p>Limit e(x) for x-&gt; oo</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.gruntz.moveup">moveup</a></td><td><span class="undocumented">Undocumented</span></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.gruntz.movedown">movedown</a></td><td><span class="undocumented">Undocumented</span></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.gruntz.subexp">subexp</a></td><td><div><p>Is &quot;sub&quot; a subexpression of &quot;e&quot;?</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.gruntz.calculate_series">calculate_series</a></td><td><div><p>Calculates at least one term of the series of &quot;e&quot; in 
&quot;x&quot;.</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.gruntz.calculate_leadterm">calculate_leadterm</a></td><td><div><p>Calculates the leadterm of &quot;e&quot; in &quot;x&quot;.</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.gruntz.mrv_leadterm">mrv_leadterm</a></td><td><div><p>Returns (c0, e0) for e.</p>
</div></td></tr><tr class="class"><td>Class</td><td><a href="sympy.series.gruntz.Limit2.html">Limit2</a></td><td><span class="undocumented">Undocumented</span></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.gruntz.gruntz">gruntz</a></td><td><div><p>Compute the limit of e(z) at the point z0 using the Gruntz 
algorithm.</p>
</div></td></tr></table>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.gruntz.debug">debug(func):</a></div>
            <div class="functionBody"><div><p>Only for debugging purposes: prints a tree</p>
<p>It will print a nice execution tree with arguments and results of all 
decorated functions.</p>
</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.gruntz.tree">tree(subtrees):</a></div>
            <div class="functionBody"><div><p>Only debugging purposes: prints a tree</p>
</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.gruntz.maketree">maketree(f, *args, **kw):</a></div>
            <div class="functionBody"><div><p>Only debugging purposes: prints a tree</p>
</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.gruntz.compare">compare(a, b, x):</a></div>
            <div class="functionBody"><div><p>Returns &quot;&lt;&quot; if a&lt;b, &quot;=&quot; for a==b, 
&quot;&gt;&quot; for a&gt;b</p>
</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.gruntz.mrv">mrv(e, x):</a></div>
            <div class="functionBody"><div><p>Returns a python set of  most rapidly varying (mrv) subexpressions of 
'e'</p>
</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.gruntz.mrv_max">mrv_max(f, g, x):</a></div>
            <div class="functionBody"><div><p>Computes the maximum of two sets of expressions f and g, which are in 
the same comparability class, i.e. max() compares (two elements of) f and g
and returns the set, which is in the higher comparability class of the 
union of both, if they have the same order of variation.</p>
</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.gruntz.rewrite">rewrite(e, Omega, x, wsym):</a></div>
            <div class="functionBody"><div><p>e(x) ... the function Omega ... the mrv set wsym ... the symbol which is
going to be used for w</p>
<p>Returns the rewritten e in terms of w and log(w). See test_rewrite1() 
for examples and correct results.</p>
</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.gruntz.sign">sign(e, x):</a></div>
            <div class="functionBody"><div><p>Returns a sign of an expression e(x) for x-&gt;oo.</p>
<p>e &gt;  0 ...  1 e == 0 ...  0 e &lt;  0 ... -1</p>
</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.gruntz.limitinf">limitinf(e, x):</a></div>
            <div class="functionBody"><div><p>Limit e(x) for x-&gt; oo</p>
</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.gruntz.moveup">moveup(l, x):</a></div>
            <div class="functionBody"><div class="undocumented">Undocumented</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.gruntz.movedown">movedown(l, x):</a></div>
            <div class="functionBody"><div class="undocumented">Undocumented</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.gruntz.subexp">subexp(e, sub):</a></div>
            <div class="functionBody"><div><p>Is &quot;sub&quot; a subexpression of &quot;e&quot;?</p>
</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.gruntz.calculate_series">calculate_series(e, x):</a></div>
            <div class="functionBody"><div><p>Calculates at least one term of the series of &quot;e&quot; in 
&quot;x&quot;.</p>
<p>This is a place that fails most often, so it is made robust so that 
meaningful errors are printed out in case of problems.</p>
</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.gruntz.calculate_leadterm">calculate_leadterm(e, x):</a></div>
            <div class="functionBody"><div><p>Calculates the leadterm of &quot;e&quot; in &quot;x&quot;.</p>
<p>Make a nice report if it fails, that signals a bug either in limits or 
series expansion.</p>
</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.gruntz.mrv_leadterm">mrv_leadterm(e, x, Omega=):</a></div>
            <div class="functionBody"><div><p>Returns (c0, e0) for e.</p>
</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.gruntz.gruntz">gruntz(e, z, z0, dir='+'):</a></div>
            <div class="functionBody"><div><p>Compute the limit of e(z) at the point z0 using the Gruntz 
algorithm.</p>
<p>z0 can be any expression, including oo and -oo.</p>
<p>For dir=&quot;+&quot; (default) it calculates the limit from the right 
(z-&gt;z0+) and for dir=&quot;-&quot; the limit from the left (z-&gt;z0-). 
For infinite z0 (oo or -oo), the dir argument doesn't matter.</p>
<p>This algorithm is fully described in the module docstring in the 
gruntz.py file. It relies heavily on the series expansion. You probably 
want to use the limit() function, that first try some heuristics and only 
when that fails, calls the gruntz() function, so limit() is much faster 
than gruntz() for the most frequent cases.</p>
</div></div>
            </div></body>
        