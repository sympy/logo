<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
        <html><head>
        <link rel="stylesheet" type="text/css" href="apidocs.css"/>
        <title>API docs for &ldquo;sympy.series.order.Order&rdquo;</title>
        </head>
        <body><h1 class="class">Class s.s.o.Order(<a href="sympy.core.basic.Basic.html">Basic</a>, <a href="sympy.core.methods.ArithMeths.html">ArithMeths</a>, <a href="sympy.core.methods.RelMeths.html">RelMeths</a>):</h1><span id="part">Part of <a href="sympy.series.order.html">sympy.series.order</a></span><div class="toplevel"><pre>Represents O(f(x)) at the point x = 0.

Definition
==========

g(x) = O(f(x)) as x->0  if and only if
|g(x)|<=M|f(x)| near x=0                     (1)

for some positive but finite M. An equivalent way of saying (1) is:

lim_{x->0}  |g(x)/f(x)|  < oo

Let's illustrate it on the following example:

sin x = x - x**3/3! + O(x**5)

where in this case O(x**5) = x**5/5! - x**7/7! + .... and the definition
of O means:

|x**5/5! - x**7/7! + ....| <= M|x**5|      near x=0

or equivalently:

lim_{x->0} | (x**5/5! - x**7/7! + ....) / x**5| < oo

which surely is true, because

lim_{x->0} | (x**5/5! - x**7/7! + ....) / x**5| = 1/5!


So intuitively O(x**3) means: all terms x**3, x**4 and
higher. But not x**2, x or 1.

Examples:
=========
>>> from sympy import *
>>> x = Symbol("x")
>>> O(x)
O(x)
>>> O(x)*x
O(x**2)
>>> O(x)-O(x)
O(x)

   External links
   --------------

     U{Big O notation<http://en.wikipedia.org/wiki/Big_O_notation>}

Properties:
===========

  g(x) = O(f(x)) as x->0  <->  |g(x)|<=M|f(x)| near x=0  <->  lim_{x->0}  |g(x)/f(x)|  < oo

  g(x,y) = O(f(x,y))  <->  lim_{x,y->0}  |g(x,y)/f(x,y)|  < oo, we'll assume that limits commute.

Notes:
======

  In O(f(x),x) the expression f(x) is assumed to have a leading term.
  O(f(x),x) is automatically transformed to O(f(x).as_leading_term(x),x).
  O(expr*f(x),x) is O(f(x),x)
  O(expr,x) is O(1)
  O(0, x) is 0.

  Multivariate O is also supported:
    O(f(x,y),x,y) is transformed to O(f(x,y).as_leading_term(x,y).as_leading_term(y), x, y)

  If O is used with only expression argument then the symbols are
  all symbols in the expression.</pre></div><table class="children"><tr class="function"><td>Function</td><td><a href="#sympy.series.order.Order.__new__">__new__</a></td><td><span class="undocumented">Undocumented</span></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.order.Order.oseries">oseries</a></td><td><div><p>Return the series of an expression up to given Order symbol (without 
the</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.order.Order.nseries">nseries</a></td><td><div><p>Calculates a generalized series expansion.</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.order.Order._get_cache_index">_get_cache_index</a></td><td><span class="undocumented">Undocumented</span></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.order.Order.find_limit">find_limit</a></td><td><div><p>Basically identical to:</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.order.Order.expr">expr</a></td><td><span class="undocumented">Undocumented</span></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.order.Order.symbols">symbols</a></td><td><span class="undocumented">Undocumented</span></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.order.Order.tostr">tostr</a></td><td><span class="undocumented">Undocumented</span></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.order.Order._eval_power">_eval_power</a></td><td><span class="undocumented">Undocumented</span></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.order.Order.as_expr_symbols">as_expr_symbols</a></td><td><span class="undocumented">Undocumented</span></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.order.Order.contains">contains</a></td><td><div><p>Return True if expr belongs to Order(self.expr, *self.symbols).</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.order.Order._eval_subs">_eval_subs</a></td><td><span class="undocumented">Undocumented</span></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.order.Order._calc_splitter">_calc_splitter</a></td><td><span class="undocumented">Undocumented</span></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.series.order.Order._sage_">_sage_</a></td><td><span class="undocumented">Undocumented</span></td></tr></table>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.order.Order.__new__">__new__(cls, expr, *symbols, **assumptions):</a></div>
            <div class="functionBody"><div class="undocumented">Undocumented</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.order.Order.oseries">oseries(self, order):</a></div>
            <div class="functionBody"><div><p>Return the series of an expression up to given Order symbol (without the
actual O term).</p>
<p>The general philosophy is this: simply start with the most simple Taylor
(Laurent) term and calculate one be one and use order.contains(term) method
to determine if your term is still significant and should be added to the 
series, or we should stop.</p>
</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.order.Order.nseries">nseries(self, x, x0, n):</a></div>
            <div class="functionBody"><div><p>Calculates a generalized series expansion.</p>
<p>The difference between oseries and nseries is that nseries calculates 
&quot;n&quot; terms in the innermost expressions and then builds up the 
final series just by &quot;cross-mutliplying&quot; everything out.</p>
<p>Advantage -- it's fast, because we don't have to determine how many 
terms we need to calculate in advance.</p>
<p>Disadvantage -- you may endup with less terms than you may have 
expected, but the O(x**n) term appended will always be correct, so the 
result is correct, but maybe shorter.</p>
</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.order.Order._get_cache_index">_get_cache_index(obj, symbol):</a></div>
            <div class="functionBody"><div class="undocumented">Undocumented</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.order.Order.find_limit">find_limit(cls, f, x):</a></div>
            <div class="functionBody"><div><p>Basically identical to:</p>
<p>return limit(f, x, 0, dir=&quot;+&quot;)</p>
<p>but first trying some easy cases (like x**2) using heuristics, to avoid 
infinite recursion. This is only needed in the Order class and series 
expansion (that shouldn't rely on the Gruntz algorithm too much), that's 
why find_limit() is defined here.</p>
</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.order.Order.expr">expr(self):</a></div>
            <div class="functionBody"><div class="undocumented">Undocumented</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.order.Order.symbols">symbols(self):</a></div>
            <div class="functionBody"><div class="undocumented">Undocumented</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.order.Order.tostr">tostr(self, level=0):</a></div>
            <div class="functionBody"><div class="undocumented">Undocumented</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.order.Order._eval_power">_eval_power(b, e):</a></div>
            <div class="functionBody"><div class="undocumented">Undocumented</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.order.Order.as_expr_symbols">as_expr_symbols(self, order_symbols):</a></div>
            <div class="functionBody"><div class="undocumented">Undocumented</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.order.Order.contains">contains(self, expr):</a></div>
            <div class="functionBody"><div><p>Return True if expr belongs to Order(self.expr, *self.symbols). Return 
False if self belongs to expr. Return None if the inclusion relation cannot
be determined (e.g. when self and expr have different symbols).</p>
</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.order.Order._eval_subs">_eval_subs(self, old, new):</a></div>
            <div class="functionBody"><div class="undocumented">Undocumented</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.order.Order._calc_splitter">_calc_splitter(self, d):</a></div>
            <div class="functionBody"><div class="undocumented">Undocumented</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.series.order.Order._sage_">_sage_(self):</a></div>
            <div class="functionBody"><div class="undocumented">Undocumented</div></div>
            </div></body>
        