<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
        <html><head>
        <link rel="stylesheet" type="text/css" href="apidocs.css"/>
        <title>API docs for &ldquo;sympy.solvers.solvers&rdquo;</title>
        </head>
        <body><h1 class="module">Module s.s.solvers</h1><span id="part">Part of <a href="sympy.solvers.html">sympy.solvers</a></span><div class="toplevel"><div><p>This module contain solvers for all kinds of equations:</p>
<ul>
  <li>
    algebraic, use solve()
  </li>
  <li>
    recurrence, use rsolve() (not implemented)
  </li>
  <li>
    differential, use dsolve() (not implemented)
  </li>
</ul>
</div></div><table class="children"><tr class="function"><td>Function</td><td><a href="#sympy.solvers.solvers.solve">solve</a></td><td><div><p>Solves univariate polynomial equations and linear systems with</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.solvers.solvers.solve_linear_system">solve_linear_system</a></td><td><div><p>Solve system of N linear equations with M variables, which means</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.solvers.solvers.solve_undetermined_coeffs">solve_undetermined_coeffs</a></td><td><div><p>Solve equation of a type p(x; a_1, ..., a_k) == q(x) where both</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.solvers.solvers.solve_linear_system_LU">solve_linear_system_LU</a></td><td><div><p>LU function works for invertible only</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.solvers.solvers.dsolve">dsolve</a></td><td><div><p>Solves any (supported) kind of differential equation.</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.solvers.solvers.solve_ODE_first_order">solve_ODE_first_order</a></td><td><div><p>a*f'(x)+b = 0</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.solvers.solvers.solve_ODE_second_order">solve_ODE_second_order</a></td><td><div><p>a*f''(x) + b*f'(x) + c*f(x) = 0</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.solvers.solvers.solve_ODE_1">solve_ODE_1</a></td><td><div><p>(x*exp(-f(x)))'' = 0</p>
</div></td></tr></table>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.solvers.solvers.solve">solve(eq, syms, simplified=True):</a></div>
            <div class="functionBody"><div><p>Solves univariate polynomial equations and linear systems with arbitrary
symbolic coefficients. This function is just a wrapper which makes analysis
of its arguments and executes more specific functions like 'roots' or 
'solve_linear_system' etc.</p>
<p>On input you have to specify equation or a set of equations (in this 
case via a list) using '==' pretty syntax or via ordinary expressions, and 
a list of variables.</p>
<p>On output you will get a list of solutions in univariate case or a 
dictionary with variables as keys and solutions as values in the other 
case. If there were variables with can be assigned with arbitrary value, 
then they will be avoided in the output.</p>
<p>Optionaly it is possible to have the solutions preprocessed using 
simplification routines if 'simplified' flag is set.</p>
<p>To solve recurrence relations or differential equations use 'rsolve' or 
'dsolve' functions respectively, which are also wrappers combining set of 
problem specific methods.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> sympy <span class="py-keyword">import</span> *
<span class="py-prompt">&gt;&gt;&gt; </span>x, y, a = symbols(<span class="py-string">'xya'</span>)</pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>r = solve(x**2 - 3*x + 2, x)
<span class="py-prompt">&gt;&gt;&gt; </span>r.sort()
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">print</span> r
<span class="py-output">[1, 2]</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>solve(x**2 == a, x)
<span class="py-output">[-a**(1/2), a**(1/2)]</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>solve(x**4 == 1, x)
<span class="py-output">[I, 1, -1, -I]</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>solve([x + 5*y == 2, -3*x + 6*y == 15], [x, y])
<span class="py-output">{y: 1, x: -3}</span></pre>
</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.solvers.solvers.solve_linear_system">solve_linear_system(system, symbols, simplified=True):</a></div>
            <div class="functionBody"><pre>Solve system of N linear equations with M variables, which means
both Cramer and over defined systems are supported. The possible
number of solutions is zero, one or infinite. Respectively this
procedure will return None or dictionary with solutions. In the
case of over definend system all arbitrary parameters are skiped.
This may cause situation in with empty dictionary is returned.
In this case it means all symbols can be assigne arbitray values.

Input to this functions is a Nx(M+1) matrix, which means it has
to be in augmented form. If you are unhappy with such setting
use 'solve' method instead, where you can input equations
explicitely. And don't worry aboute the matrix, this function
is persistent and will make a local copy of it.

The algorithm used here is fraction free Gaussian elimination,
which results, after elimination, in upper-triangular matrix.
Then solutions are found using back-substitution. This approach
is more efficient and compact than the Gauss-Jordan method.

>>> from sympy import *
>>> x, y = symbols('xy')

Solve the following system:

       x + 4 y ==  2
    -2 x +   y == 14

>>> system = Matrix(( (1, 4, 2), (-2, 1, 14)))
>>> solve_linear_system(system, [x, y])
{y: 2, x: -6}</pre></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.solvers.solvers.solve_undetermined_coeffs">solve_undetermined_coeffs(equ, coeffs, sym, simplified=True):</a></div>
            <div class="functionBody"><div><p>Solve equation of a type p(x; a_1, ..., a_k) == q(x) where both p, q are
univariate polynomials and f depends on k parameters. The result of this 
functions is a dictionary with symbolic values of those parameters with 
respect to coefficiens in q.</p>
<p>This functions accepts both Equations class instances and ordinary SymPy
expressions. Specification of parameters and variable is obligatory for 
efficiency and simplicity reason.</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> sympy <span class="py-keyword">import</span> *
<span class="py-prompt">&gt;&gt;&gt; </span>a, b, c, x = symbols(<span class="py-string">'a'</span>, <span class="py-string">'b'</span>, <span class="py-string">'c'</span>, <span class="py-string">'x'</span>)</pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>solve_undetermined_coeffs(2*a*x + a+b == x, [a, b], x)
<span class="py-output">{a: 1/2, b: -1/2}</span></pre>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>solve_undetermined_coeffs(a*c*x + a+b == x, [a, b], x)
<span class="py-output">{a: 1/c, b: -1/c}</span></pre>
</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.solvers.solvers.solve_linear_system_LU">solve_linear_system_LU(matrix, syms):</a></div>
            <div class="functionBody"><div><p>LU function works for invertible only</p>
</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.solvers.solvers.dsolve">dsolve(eq, funcs):</a></div>
            <div class="functionBody"><pre>Solves any (supported) kind of differential equation.

Usage
=====
    dsolve(f, y(x)) -> Solve a differential equation f for the function y


Details
=======
    @param f: ordinary differential equation (either just the left hand
        side, or the Equality class)

    @param y: indeterminate function of one variable

    - you can declare the derivative of an unknown function this way:
    >>> from sympy import *
    >>> x = Symbol('x') # x is the independent variable
    
    >>> f = Function("f")(x) # f is a function of x
    >>> f_ = Derivative(f, x) # f_ will be the derivative of f with respect to x

    - This function just parses the equation "eq" and determines the type of
    differential equation, then it determines all the coefficients and then
    calls the particular solver, which just accepts the coefficients.
    - "eq" can be either an Equality, or just the left hand side (in which
      case the right hand side is assumed to be 0)
    - see test_ode.py for many tests, that serve also as a set of examples
      how to use dsolve

Examples
========
    >>> from sympy import *
    >>> x = Symbol('x')

    >>> f = Function('f')
    >>> dsolve(Derivative(f(x),x,x)+9*f(x), f(x))
    C1*sin(3*x) + C2*cos(3*x)
    >>> dsolve(Derivative(f(x),x,x)+9*f(x)+1==1, f(x))
    C1*sin(3*x) + C2*cos(3*x)</pre></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.solvers.solvers.solve_ODE_first_order">solve_ODE_first_order(a, b, f, x):</a></div>
            <div class="functionBody"><div><p>a*f'(x)+b = 0</p>
</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.solvers.solvers.solve_ODE_second_order">solve_ODE_second_order(a, b, c, f, x):</a></div>
            <div class="functionBody"><div><p>a*f''(x) + b*f'(x) + c*f(x) = 0</p>
</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.solvers.solvers.solve_ODE_1">solve_ODE_1(f, x):</a></div>
            <div class="functionBody"><div><p>(x*exp(-f(x)))'' = 0</p>
</div></div>
            </div></body>
        