<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
        <html><head>
        <link rel="stylesheet" type="text/css" href="apidocs.css"/>
        <title>API docs for &ldquo;sympy.printing.printer.Printer&rdquo;</title>
        </head>
        <body><h1 class="class">Class s.p.p.Printer(object):</h1><span id="part">Part of <a href="sympy.printing.printer.html">sympy.printing.printer</a></span><p>known subclasses: <a href="sympy.printing.pretty.pretty.PrettyPrinter.html">sympy.printing.pretty.pretty.PrettyPrinter</a>, <a href="sympy.printing.latex.LatexPrinter.html">sympy.printing.latex.LatexPrinter</a>, <a href="sympy.printing.mathml.MathMLPrinter.html">sympy.printing.mathml.MathMLPrinter</a></p><div class="toplevel"><pre>Generic printer driver

This is a generic printer driver.
It's job is to provide infrastructure for implementing new printers easily.

Basically, if you want to implement a printer, all you have to do is:

1. Subclass Printer.
2. In your subclass, define _print_<CLASS> methods

   For each class you want to provide printing to, define an appropriate
   method how to do it. For example if you want a class FOO to be printed in
   it's own way, define _print_FOO:

   def _print_FOO(self, e):
       ...

   this should return how FOO instance e is printed

   Also, if BAR is a subclass of FOO, _print_FOO(bar) will be called for
   instance of BAR, if no _print_BAR is provided.  Thus, usually, we don't
   need to provide prining routines for every class we want to support --
   only generic routine has to be provided for a set of classes. 

   A good example for this are functions - for example PrettyPrinter only
   defines _print_Function, and there is no _print_sin, _print_tan, etc...

   On the other hand, a good printer will probably have to define separate
   routines for Symbol, Atom, Number, Integral, Limit, etc...

3. If convenient, override self.emptyPrinter

   This callable will be called to obtain printing result as a last resort,
   that is when no appropriate _print_<CLASS> was found for an expression.</pre></div><table class="children"><tr class="function"><td>Function</td><td><a href="#sympy.printing.printer.Printer.__init__">__init__</a></td><td><span class="undocumented">Undocumented</span></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.printing.printer.Printer.doprint">doprint</a></td><td><div><p>Returns printer's representation for expr (as a string)</p>
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.printing.printer.Printer._print">_print</a></td><td><div><p>internal dispatcher</p>
</div></td></tr></table>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.printing.printer.Printer.__init__">__init__(self):</a></div>
            <div class="functionBody"><div class="undocumented">Undocumented</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.printing.printer.Printer.doprint">doprint(self, expr):</a></div>
            <div class="functionBody"><div><p>Returns printer's representation for expr (as a string)</p>
</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.printing.printer.Printer._print">_print(self, expr):</a></div>
            <div class="functionBody"><pre>internal dispatcher

It's job is to loop through expr classes (class + it's bases), and
try to dispatch the work to _print_<EXPR_CLASS>

e.g., suppose we have the following class hierarcy::

      Basic
        |
      Atom
        |
      Number
        |
     Rational

then, for expr=Rational(...), in order to dispatch, we will try
calling printer methods as shown in the figure below:

    p._print(expr)
    |
    |-- p._print_Rational(expr)
    |
    |-- p._print_Number(expr)
    |
    |-- p._print_Atom(expr)
    |
    `-- p._print_Basic(expr)

if ._print_Rational method exists in the printer, then it is called,
and the result is returned back.

otherwise, we proceed with trying Rational bases in the inheritance
order.

if nothing exists, we just return:

    p.emptyPrinter(expr)</pre></div>
            </div></body>
        