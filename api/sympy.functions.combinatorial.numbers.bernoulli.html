<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
        <html><head>
        <link rel="stylesheet" type="text/css" href="apidocs.css"/>
        <title>API docs for &ldquo;sympy.functions.combinatorial.numbers.bernoulli&rdquo;</title>
        </head>
        <body><h1 class="class">Class s.f.c.n.bernoulli(<a href="sympy.core.function.Function.html">Function</a>):</h1><span id="part">Part of <a href="sympy.functions.combinatorial.numbers.html">sympy.functions.combinatorial.numbers</a></span><div class="toplevel"><pre>Bernoulli numbers / Bernoulli polynomials

Usage
=====
    bernoulli(n) gives the nth Bernoulli number, B_n
    bernoulli(n, x) gives the nth Bernoulli polynomial in x, B_n(x)

Examples
========
    >>> from sympy import *

    >>> [bernoulli(n) for n in range(11)]
    [1, -1/2, 1/6, 0, -1/30, 0, 1/42, 0, -1/30, 0, 5/66]
    >>> bernoulli(1000001)
    0

Mathematical description
========================
    The Bernoulli numbers are a sequence of rational numbers
    defined by B_0 = 1 and the recursive relation (n > 0)

            n
           ___
          \      / n + 1 \
      0 =  )     |       | * B .
          /___   \   k   /    k
          k = 0

    They are also commonly defined by their exponential generating
    function, which is x/(exp(x) - 1). For odd indices > 1, the
    Bernoulli numbers are zero.

    The Bernoulli polynomials statisfy the analogous formula
                n
               ___
              \      / n \         n-k
      B (x) =  )     |   | * B  * x   .
       n      /___   \ k /    k
              k = 0

    Bernoulli numbers and Bernoulli polynomials are related as
    B_n(0) = B_n.

Implementation
==============
    We compute Bernoulli numbers using Ramanujan's formula

                               / n + 3 \
      B   =  (A(n) - S(n))  /  |       |
       n                       \   n   /

    where A(n) = (n+3)/3 when n = 0 or 2 (mod 6), A(n) = -(n+3)/6
    when n = 4 (mod 6), and

             [n/6]
              ___
             \      /  n + 3  \
      S(n) =  )     |         | * B
             /___   \ n - 6*k /    n-6*k
             k = 1

    This formula is similar to the sum given in the definition, but
    cuts 2/3 of the terms. For Bernoulli polynomials, we use the
    formula in the definition.

References and further reading
==============================
    * http://en.wikipedia.org/wiki/Bernoulli_number
    * http://en.wikipedia.org/wiki/Bernoulli_polynomial</pre></div><table class="children"><tr class="function"><td>Function</td><td><a href="#sympy.functions.combinatorial.numbers.bernoulli._calc_bernoulli">_calc_bernoulli</a></td><td><span class="undocumented">Undocumented</span></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.functions.combinatorial.numbers.bernoulli.canonize">canonize</a></td><td><div><p>Returns a canonical form of cls applied to arguments args.</p>
</div></td></tr></table>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.functions.combinatorial.numbers.bernoulli._calc_bernoulli">_calc_bernoulli(n):</a></div>
            <div class="functionBody"><div class="undocumented">Undocumented</div></div>
            </div>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.functions.combinatorial.numbers.bernoulli.canonize">canonize(cls, n, sym=None):</a></div>
            <div class="functionBody"><pre>Returns a canonical form of cls applied to arguments args.

The canonize() method is called when the class cls is about to be
instantiated and it should return either some simplified instance
(possible of some other class), or if the class cls should be
unmodified, return None.

Example of canonize() for the function "sign"
---------------------------------------------

@classmethod
def canonize(cls, arg):
    if isinstance(arg, Basic.NaN):
        return S.NaN
    if isinstance(arg, Basic.Zero): return S.One
    if arg.is_positive: return S.One
    if arg.is_negative: return S.NegativeOne
    if isinstance(arg, Basic.Mul):
        coeff, terms = arg.as_coeff_terms()
        if not isinstance(coeff, Basic.One):
            return cls(coeff) * cls(Basic.Mul(*terms))</pre></div>
            </div></body>
        