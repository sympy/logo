<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
        <html><head>
        <link rel="stylesheet" type="text/css" href="apidocs.css"/>
        <title>API docs for &ldquo;sympy.core.function&rdquo;</title>
        </head>
        <body><h1 class="module">Module s.c.function</h1><span id="part">Part of <a href="sympy.core.html">sympy.core</a></span><div class="toplevel"><pre>NOTE: this doctest is for now obsoleted interface.

There are different types of functions:
1) defined function like exp or sin that has a name and body
   (in the sense that function can be evaluated).
    e = exp
2) undefined function with a name but no body. Undefined
  functions can be defined using Symbol class as follows:
    f = Symbol('f', function=True)
  (the result will be Function instance)
  or
    f = Function('f')
3) anonymous function or lambda function that has no name
   but has body with dummy variables. An anonymous function
   object creation examples:
    f = Lambda(x, exp(x)*x)
    f = Lambda(exp(x)*x)  # free symbols in the expression define the number of arguments
    f = exp * Lambda(x,x)
4) composition of functions, inverse functions

One can perform certain operations with functions, the
result will be a lambda function. Allowed operations are
addition and multiplication. Function multiplication is
elementise ie (f*g)(x) is equivalent to f(x) * g(x).
Multiplication by a number is equivalent to multiplication
by a constant function.
Composition of functions is achived via Composition class@
Eg

  f+Composition(2,exp,sin) -> lambda _x: f(x)+2*exp(sin(x))

In the above functions did not have arguments, then
it is said that functions are in unevaluated form.
When calling a function with arguments, then we get
an instance of the function value. Eg

  exp(1) -> 1
  (2*f)(x)  -> 2 * f(x)
  Lambda(x, exp(x)*x)(y) -> exp(y)*y

One can construct undefined function values from Symbol
object:
  f = Symbol('f')
  fx = f(x)
  fx.func -> Function('f')
  fx[:] -> (Symbol('x'),)
As seen above, function values are Apply instances and
have attributes .func and [:].</pre></div><table class="children"><tr class="class"><td>Class</td><td><a href="sympy.core.function.FunctionClass.html">FunctionClass</a></td><td><div>Base class for function classes. FunctionClass is a subclass of 
type.
</div></td></tr><tr class="class"><td>Class</td><td><a href="sympy.core.function.Function.html">Function</a></td><td><div>Base class for applied functions.
</div></td></tr><tr class="class"><td>Class</td><td><a href="sympy.core.function.WildFunction.html">WildFunction</a></td><td><span class="undocumented">Undocumented</span></td></tr><tr class="class"><td>Class</td><td><a href="sympy.core.function.Lambda.html">Lambda</a></td><td><div>Lambda(expr, arg1, arg2, ...) -&gt; lambda arg1, arg2,... : expr
</div></td></tr><tr class="class"><td>Class</td><td><a href="sympy.core.function.Derivative.html">Derivative</a></td><td><div>Carries out differentation of the given expression with respect to 
symbols.
</div></td></tr><tr class="function"><td>Function</td><td><a href="#sympy.core.function.diff">diff</a></td><td><div>Differentiate f with respect to x
</div></td></tr></table>
            <div class="function">
            <div class="functionHeader">def <a name="sympy.core.function.diff">diff(f, x, times=1, evaluate=True):</a></div>
            <div class="functionBody"><div><p>Differentiate f with respect to x</p>
<p>It's just a wrapper to unify .diff() and the Derivative class, it's 
interface is similar to that of integrate()</p>
see 
http://documents.wolfram.com/v5/Built-inFunctions/AlgebraicComputation/Calculus/D.html
</div></div>
            </div></body>
        