#summary Documentation to sympy.
#labels Featured

= Introduction =

This document describes the main ideas of how sympy works. For examples of most features of sympy, look into [http://code.google.com/p/sympy/wiki/Examples Examples].

For some ideas, where Sympy can be used, see http://code.google.com/p/sympy/wiki/Motivation.


= Basics =

All symbolic things are implemented using subclasses of the `basic` class.
First, you need to create symbols using `symbol("x")` or numbers using
`rational(5)` or `real(34.3)`. Then you construct the expression using any class
from sympy.  For example `add(symbol("a"),symbol("b"))` gives an
instance of the `add` class.  You can call all methods, which the particular
class supports.

For easier use, there is a syntactic sugar for expressions like:

`cos(x)+1` is equal to `cos(x).__add__(1)` is equal to `add(cos(x),rational(1))` 

or

`2/cos(x)` is equal to `cos(x).__rdiv__(2)` is equal to `mul(rational(2),pow(cos(x),rational(-1)))`.

So, you can write normal expressions using python arithmetics like this:
{{{
a=symbol("a")
b=symbol("b")
e=(a+b)**2
print e
}}}
but from the sympy
point of view, we just need the classes `add`, `mul`, `pow`, `rational`.

= Canonical form: eval() =

During the construction of the expression, the result is unevaluated, so this
phase is really fast. For computation, the expression needs to be in a
canonical form, this is achieved using the method `eval()`, which  only performs
unexpensive operations necessary to put the expression in the canonical form.
So the canonical form doesn't mean the simplest possible expresion. The exact
list of operations performed by `eval()` depends on the implementation.
Obviously, the definition of the canonical form is arbitrary, the only
requirement is that all equivalent expressions must have the same canonical
form.  We tried the conversion to a canonical (standard) form to be as fast as possible and
also in a way so that the result is what you would write by hand - so for example `b*a + -4 + b + a*b + 4 + (a+b)^2` becomes `2*a*b + b + (a+b)^2`.  The order of terms in the
sum is sorted according to their hash values, so they don't have to be in the
alphabetical order (depends on the hash implementation).

The polic is, that the user (you) shouldn't need to call `eval()` directly. The methods, which need evaluated arguments, should evaluate them themselves. The only argument against this behavior is the speed - some expressions would be evaluated several times. This could be possibly handled by some caching mechanism. 

= Comparisons =

Expressions can be compared using a regular python syntax:
{{{
a+b==b+a
}}}
This is equivalent to `(a+b).eq(b+a)` and the `basic.eq()` method just calls eval() to both `self` and the argument and then compare the hashes.

Whic means that if the expansion operation is not performed upon evaluation (which is
reasonable), then `(a+b)^2 != (a^2+2ab+b^2)`, on the other hand
`((a+b)^2).expand() == (a^2+2ab+b^2)`. As we said, what exactly is performed in `eval()` depends on the implementation, for example the expansion would be in `pow.eval()`. In the current implementation of sympy, we do not perform expansion in `pow.eval()`.

We made this decision in sympy: `a=symbol("x")` and another `b=symbol("x")` (with the same string "x") is the same thing, i.e `a==b` is `True`. Note that this is different from Ginac. We chose `a==b`, because it is more
natural - `exp(x)==exp(x)` for the same intance of `x` but different instances of `exp`, so we chose to have `exp(x)==exp(x)` even for different instances of `x`. 

Sometimes, you need to have a unique symbol, for example as a temporary one in some calculation, which is going to be substituted for something else at the end anyway. This is achieved using `symbol("x",dummy=True)` or simply as `symbol("x",True)`. So, to sum it up: `symbol("x")==symbol("x")`, but `symbol("x",True)!=symbol("x",True)`.

= Functionality =

There are no given requiremens on classes in the library. For example, if they
don't implement the `diff()` method and you construct an expression using such a
class, then trying to use the `basic.series()` method will raise an exception of not
founding the `diff()` method in your class. This "duck typing" has an advantage
that you just implement the functionality which you need. You can define the
function `cos` like this
{{{
class cos(basic):
    def __init__(self,arg):
        basic.__init__(self)
        self.arg=arg
}}}
and use it like `1+cos(x)`, but if you don't implement the `diff()` method, you
will not be able to call `(1+cos(x)).series()`.
the symbolic object is characterized (defined) by the things which it can do.
so implementing more methods like `diff`, `subs` etc., you are creating a "shape" of the symbolic object. Useful things to implement in new classes are: `hash` (to use the class in comparisons), `diff` (to use it in series expansion), `subs` (to use it in expressions, where some parts are being substituted), `series` (if the series cannot be computed using the general `basic.series()` method). When you create a new class, don't worry about this too much - just try to use it in your code, and you will realize immediately, which methods need to be implemented in each situation.

All objects in the sympy are immutable - in the sense, that any
operation (like `eval()` for example) just returns a new instance (it can
return the same instance only if it didn't change). This is a common mistake
to change the current instance, like `self.arg=self.arg.eval()` (wrong!). Use
`arg=self.arg.eval();return exp(arg)` instead. The object in immutable in the
sense of the symbolic expression it represents. It can modify itself to keep
track of for example the evaluated variable. Or hash. Or it can precalculate
anything regarding the expression it contains. But the expression cannot be
changed. So you can pass any instance to other objects, because you don't have
to worry that it will change, or that this would break anything.

= Conclusion =

So, those are the main ideas behind sympy, which we try to obey. The rest depends on the current implementation and can possibly change in the future. The point of all of this is that the inter dependecies inside sympy should be kept to a minimum. If one wants to add new functionality to sympy, all that is necessary is to create a subclass of `basic` and implement what you want. Compare this to for example `ginac`.