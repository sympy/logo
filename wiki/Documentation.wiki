#summary Documentation to sympy.

= Introduction =

This document describes the main ideas of how sympy works. For examples of most features of sympy, look into [http://code.google.com/p/sympy/wiki/Examples Examples].




= Basics =

All symbolic things are implemented using subclasses of the `basic` class.
First, you need to create symbols using `symbol("x")` or numbers using
`rational(5)` or `real(34.3)`. Then you construct the expression using any class
from sympy.  For example `add(symbol("a"),symbol("b"))` gives an
instance of the `add` class.  You can call all methods, which the particular
class supports.

For easier use, there is a syntactic sugar for expressions like:

`cos(x)+1` is equal to `cos(x).__add__(1)` is equal to `add(cos(x),rational(1))` 

or

`2/cos(x)` is equal to `cos(x).__rdiv__(2)` is equal to `mul(rational(2),pow(cos(x),rational(-1)))`.

So, you can write normal expressions using python arithmetics like this:
{{{
a=symbol("a")
b=symbol("b")
e=(a+b)**2
print e
}}}
but from the sympy
point of view, we just need the classes `add`, `mul`, `pow`.

= Canonical form: eval() =

During the construction of the expression, the result is unevaluated, so this
phase is really fast. For computation, the expression needs to be in a
canonical form, this is achieved using the method `eval()`, which  only performs
unexpensive operations necessary to put the expression in the canonical form.
So the canonical form doesn't mean the simplest possible expresion. The exact
list of operations performed by `eval()` depends on the implementation.
Obviously, the definition of the canonical form is arbitrary, the only
requirement is that all equivalent expressions must have the same canonical
form.  We tried the conversion to a canonical (standard) form to be as fast as possible and
also in a way so that the result is what you would write by hand - so for example `b*a + -4 + b + a*b + 4 + (a+b)^2` becomes `2*a*b + b + (a+b)^2`.  The order of terms in the
sum is sorted according to their hash values, so they don't have to be in the
alphabetical order (depends on the hash implementation).

== Comparisons ==

Expressions can be compared using a regular python syntax:
{{{
a+b==b+a
}}}
This is equivalent to `(a+b).eq(b+a)` and the `basic.eq()` method just calls eval() to both `self` and the argument and then compare the hashes.

Whic means that if the expansion operation is not performed upon evaluation (which is
reasonable), then `(a+b)^2 != (a^2+2ab+b^2)`, on the other hand
`((a+b)^2).expand == (a^2+2ab+b^2)`. 

a=symbol("x") and another b=symbol("x") is the same thing, i.e a==b is True.
Note that this is different from Ginac. We chose a==b, because it seems more
natural. In the future, we should implement a=symbol(), to get a unique symbol,
to use for internal computations.

== Functionality == 

There is no given requiremens on classes in the library. For example, if they
don't implement the `diff()` method and you construct an expression using such a
class, then trying to use the `basic.series()` method will raise an exception of not
founding the `diff()` method in your class. This "duck typing" has an advantage
that you just implement the functionality which you need. You can define the
function `cos` like this
{{{
class cos(basic):
    def __init__(self,arg):
        basic.__init__(self)
        self.arg=arg
}}}
and use it like `1+cos(x)`, but if you don't implement the `diff()` method, you
will not be able to call `(1+cos(x)).series()`.
the symbolic object is characterized (defined) by the things which it can do.
so implementing more methods like `diff`, `subs` etc., you are creating a "shape" of the symbolic object. Useful things to implement in new classes are: `diff`, `subs`, `series`.


All objects in the sympy are immutable - in the sense, that any
operation (like `eval()` for example) just returns a new instance (it can
return the same instance only if it didn't change). This is a common mistake
to change the current instance, like `self.arg=self.arg.eval()` (wrong!). Use
`arg=self.arg.eval();return exp(arg)` instead. The object in immutable in the
sense of the symbolic expression it represents. It can modify itself to keep
track of for example the evaluated variable. Or hash. Or it can precalculate
anything regarding the expression it contains. But the expression cannot be
changed. So you can pass any instance to other objects, because you don't have
to worry that it will change, or that this would break anything.


=== Basics ===

Every symbolic object and operation is implemented using a class and all such classes in sympy are derived from `basic`. 

Example: the expression (a+b)^2 is represented by `pow( add(symbol("a"),symbol("b")), rational(2))`. All `pow`, `add`, `symbol` classes are derived from `basic`. 

There is no conceptual difference between operations (like `*`,`+`,`/`) and other symbolic objects (like symbols and numbers). All the functionality is implemented in the particular class, so for example `add` knows how to collect the same terms (i.e. to reduce `add(mul(a,b),mul(b,a))` to `mul(mul(rational(2),a), b)`).

*Syntactic sugar*: The operations `+`, `-`, `*`, `/` and `^` are also defined in the class `basic` using the python methods `__add__`, `__sub__`, `__mul__`, `__div__` and `__pow__`. So in our example, we can actually write `(symbol("a")+symbol("b"))**rational(2)`, which will return `pow( add(symbol("a"),symbol("b")), rational(2))`. Some classes also accept python `int`s as input, so you can write `(symbol("a")+symbol("b"))**2` instead of `(symbol("a")+symbol("b"))**rational(2)`. The common practice is to write code like this:
{{{
a=symbol("a")
b=symbol("b")
e=(a+b)**2
print e
}}}
So you are writing expressions in a natural way, but there is no magic behind it, it is completely equivalent to constructing the expressions using the sympy classes directly. From the sympy point of view, you don't have to know about the syntactic sugar at all, all the expressions are just in the form `pow( add(symbol("a"),symbol("b")), rational(2))`.

=== eval() ===

The `eval()` method is implemented in all sympy classes and it returns the same expression represented by the class, but put in a canonical form.

Example: `add(mul(a,b),mul(b,a)).eval()` returns `mul(mul(rational(2),a), b)`.

