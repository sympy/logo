#summary First steps with sympy


== Installation ==

 * debian. Download the deb file from the project's homepage, and then install in with the command `"sudo dpkg -i python-sympy_$version_all.deb"`, where `$version` must be replaced with the version number. 

  Hopefully, we'll soon (couple of weeks) have this package in the official debian main repository.

 * source. 
    # unix systems (linux, BSD, cygwin, etc.). Download the source archive, (something like `sympy-$version.tar.gz`), extract it with the command `"tar xvvzf sympy-$version.tar.gz"`, and follow the README located in the sympy directory

 * windows. Downlad the windows installer from the homepage and execute it. 

== What you'll need to follow this tutorial ==

 * `isympy`: all examples are made within `isympy`. `isympy` (located in `bin/isympy`) is just a standard python shell that has already imported the relevant sympy modules and defined the symbols x, y and z. So if you can't run isympy (by calling `bin/isympy`), then (after filling a bug report:) you'll have to run the following code at the beginning of each session: 

{{{
   >>> from sympy import *
   >>> x = Symbol('x')
   >>> y = Symbol('y')
   >>> z = Symbol('z')
}}}

= Using SymPy as a calculator =

Sympy has two built-in numeric types: [http://sympy.googlecode.com/svn/api/sympy.core.numbers.Real-class.html Real] and [http://sympy.googlecode.com/svn/api/sympy.core.numbers.Rational-class.html Rational]. 

The Rational class represents a rational number as a pair of two integers: the numerator and the denominator, so Rational(1,2) represents 1/2, Rational(5,2) 5/2 and so on. 

{{{
  In [0]: a = Rational(1,2)

  In [1]: a
  Out[1]: 1/2

  In [2]: a*2
  Out[2]: 1

  In [3]: Rational(2)**50/Rational(10)**50
  Out[3]: 1/88817841970012523233890533447265625
}}}

proceed with caution while working with python int's since they truncate integer division, and that's why: 

{{{
   In [2]: 1/2
   Out[2]: 0

   In [3]: 1.0/2
   Out[3]: 0.5

}}}

You can however do:
{{{
  In [1]: from __future__ import division

  In [2]: 1/2 
  Out[2]: 0.5
}}}
It's going to be standard in python, hopefully soon....

we also have some special constants, like e and pi, that are treated as symbols (1+pi won't evaluate to something numeric, rather it will remain as 1+pi), and have arbitrary precission: 

{{{
   In [1]: pi**2
   Out[1]: pi**2

   In [2]: pi.evalf()
   Out[2]: 3.1416...

   In [2]: (pi+e).evalf()
   Out[2]: ...
}}}

as you see, evalf evaluates the expression to a floating-point number

There is also a class representing mathematical infinity, and we call it infty, however, you can't do normal arithmetic operations for infinity, as it is only used for comparisions, like

{{{
In [1]: infty != 2
True
}}}

You can play with symbols:

{{{
In [1]: x+y+x-y
Out[1]: 2*x

In [2]: (x+y)**2
Out[2]: (x+y)**2

In [3]: ((x+y)**2).expand()
Out[3]: 2*x*y+y**2+x**2
}}}

And substitute them for other symbols or numbers using `subs(var, substitution)`:

{{{
In [1]: ((x+y)**2).subs(x, 1)
Out[1]: (1+y)**2

In [2]: ((x+y)**2).subs(x, y)
Out[2]: 4*y**2
}}}

= Calculus =

== Limits ==

Limits are implemented in the module sympy.modules.limits and are imported by `from sympy import *`, that is automatically executed by `isympy`, so you don't have to worry about it.

Limits are easy to use in sympy, they follow the syntax limit(function, variable, point), so to compute the limit of f(x) as x -> 0, you would issue limit(f, x, 0)

{{{
   In [1]: limit(sin(x)/x, x, 0)
   Out[1]: 1

}}}

you can also calculate the limit at infinity: 

{{{
   In [1]: limit(x, x, infty)
   Out[1]: Infinity

   In [2]: limit(1/x, x, infty)
   Out[2]: 0

   In [3]: limit((5**x+3**x)**(1/x), x, infty)
   Out[3]: 5
}}}

for some non-trivial examples on limits, you can read the test file [http://sympy.googlecode.com/svn/trunk/tests/test_demidovich.py test_demidovich.py]

== Differentiation ==

You can differentiate any !SymPy expression using `.diff(var)`. Examples:

{{{
In [1]: sin(x).diff(x)
Out[1]: cos(x)

In [2]: sin(2*x).diff(x)
Out[2]: 2*cos(2*x)

In [3]: tan(x).diff(x)
Out[3]: cos(x)**(-2)
}}}

You can check, that it is correct by:

{{{
In [4]: limit((tan(x+y)-tan(x))/y, y, 0)
Out[4]: cos(x)**(-2)
}}}

Higher derivatives can be calculated using the `.diffn(var, n)` method:

{{{
In [5]: sin(2*x).diffn(x,1)
Out[5]: 2*cos(2*x)

In [6]: sin(2*x).diffn(x,2)
Out[6]: -4*sin(2*x)

In [7]: sin(2*x).diffn(x,3)
Out[7]: -8*cos(2*x)
}}}

== Series expansion ==

Use `.series(var, order)`:

{{{
In [1]: cos(x).series(x,10)
Out[1]: 1-1/3628800*x**10+1/40320*x**8+1/24*x**4-1/720*x**6-1/2*x**2

In [2]: (1/cos(x)).series(x,10)
Out[2]: 1+5/24*x**4+277/8064*x**8+50521/3628800*x**10+61/720*x**6+1/2*x**2
}}}

The terms are ordered according to their hashes, that's why they look random.

== Integration ==

Currently, !SymPy can only do some simple integrals. 

Documentation and examples are at http://sympy.googlecode.com/svn/api/sympy.modules.integrals-module.html#integrate

= Linear Algebra =

== Matrices ==

Matrices are created as instances from the [http://sympy.googlecode.com/svn/api/sympy.modules.matrices.Matrix-class.html Matrix] class. This class is located in sympy.modules.matrices, but at usual, isympy imports this for you: 

{{{
In [13]: Matrix([[1,0], [0,1]])
Out[13]: 
1 0 
0 1 
}}}

you can also put Symbols in it: 
{{{
In [15]: A = Matrix([[1,x], [y,1]])

In [16]: A
Out[16]: 
1 x 
y 1 

In [17]: A**2
Out[17]: 
1+y*x 2*x 
2*y 1+y*x 
}}}


= Pattern matching =

Use the `.match()` method (available in 0.4), that returns a dictionary. Examples:

{{{
In [1]: (3*x**2 + x).match(y*x**2 + z*x, [y,z])
Out[1]: {y: 3, z: 1}

In [2]: (x**2).match(y*x**z, [y,z])
Out[2]: {y: 1, z: 2}
}}}

If the match is unsuccessful, it returns `None`:

{{{
In [25]: (x**2).match(y*x**3, [y,z])

In [26]: print (x**2).match(y*x**3, [y,z])
None
}}}

If the match is successful, but the variables are not matched, they are simply not returned in the dictionary:
{{{ 
In [27]: (x**2).match(y*x**2, [y,z])
Out[27]: {y: 1}

In [28]: (x**2).match(x**2, [y,z])
Out[28]: {}
}}}