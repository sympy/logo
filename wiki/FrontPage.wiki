#summary A wiki for the frontpage (this line will not be visible on the front page)

!SymPy is a symbolic manipulation package, written in pure Python. Its
aim is to become a full featured CAS in Python, while keeping the
code as simple as possible in order to be comprehensible and
easily extensible.

==News==

  * *12 Apr 2007* The Google Summer of Code applications results are available. See [http://code.google.com/p/sympy/wiki/GSoC2007 GSoC2007]
  * *25 Mar 2007* Version 0.3 released. Look at [http://code.google.com/p/sympy/wiki/Changes changes] since the last release.
  * *15 Mar 2007* We are accepting applications for the Google Summer of Code, see SummerOfCode. Deadline is March 26th.
  * *12 Mar 2007* Version 0.2 released.

==Features==

Currently, !SymPy core has only around 1500 lines of code (including extensive comments) and its capabilities include:

  * basic arithmetics `*,/,+,-`
  * basic simplification (like `a*b*b + 2*b*a*b  -> 3*a*b^2`)
  * expansion (like `(a+b)^2 -> a^2 + 2*a*b + b^2`)
  * functions (exp, ln, sin, cos, tan, ...)
  * complex numbers (like `exp(I*x).evalc()  -> cos(x)+I*sin(x)`)
  * differentiation
  * taylor series
  * basic substitution (like x-> ln(x))
  * arbitrary precision integers, rationals and floats
  * noncommutative symbols
 
Then there are !SymPy modules (1000 lines) for these tasks:

  * limits (like `limit(x*log(x), x, 0) -> 0`)
  * integration (currently it can only do very simple integrals)
  * polynomials (division, gcd, square free decomposition)
  * symbolic matrices
  * Pauli and Dirac algebra


===Things we are working on===
 
  * Implement featues of GiNaC that !SymPy cannot yet do (we are almost there)
  * See [http://code.google.com/p/sympy/issues/list Issues] for details and other things

===Some ideas for future development===

  * implement factorisation, Risch integration algorithm (see our [http://code.google.com/p/sympy/wiki/SymbolicIntegration notes]), asymptotic expansion, equations solving, linear algebra, objects with indices (tensors) and more...

==Download and installation==

See the [DownloadInstallation instructions].



==Documentation==

All the documentation is in the wiki:

http://code.google.com/p/sympy/wiki/Documentation


==Motivation==

Why not use CAS with its own language (like Maple/Mathematica/Maxima)
is best described by: http://www.ginac.de/FAQ.html#whynotmaple

We want to use CAS from a 'classic' language like C, C++, Python (maybe
Java, Ruby, and C# as well). There are many symbolic manipulation programs (see the links), but currently, there are only three libraries, GiNaC, Giac
(both for C++) and SAGE (Python, see below) that satisfy this need. Even GiNaC and Giac are too
complicated (thousands lines of code) and difficult to extend, unfortunately. !SymPy
tries to be as simple as possible while remaining a full
featured CAS. This means that we prefer the algorithm that is
implemented by the least amount of lines; also, we try to avoid
implementing one feature several times - a special
multiplication algorithm for polynomials, for instance - if it works with the
general algorithm. It will not be as fast (it wouldn't be anyway,
it's written in Python) as it could, but it will be easy to extend with your own new algorithms or symbolic functions. And your code is just a regular Python program, calling !SymPy as a regular module, so you are not stuck in a language of the CAS system, which is not well designed for real programming.

Later, we might implement special algorithms for special cases to
make it faster and also rewrite it in C++. It is not certain though, that
a general purpose CAS (which !SymPy is intended to be) can be as fast as a
specialised CAS (say, for polynomial computations). The aim is to play
with the problem in !SymPy, implement a working algorithm, and later,
if it works and is not fast enough, implement it in
a different language, more suitable for the task. 

To sum it up: It would be nice to have an opensource alternative to Maple/Mathematica, that is reasonably fast (maybe written in C++), could be easily extended with your own ideas, would be callable from python and could be used in real world problems (as Maple/Mathematica can). SAGE is also trying to achieve this goal (see also their [http://modular.math.washington.edu/sage/doc/html/tut/node58.html Why Python?] explanation), but from a different side - !SymPy aims to be a lightweight normal python module, whereas SAGE aims
to glue together every useful open source mathematics software package
and provide a transparent interface to all of them (and thus is quite huge and currently cannot be used as a python module). We will try to integrate !SymPy into SAGE (as an optional module) in the future, so that it can be used from SAGE. SAGE is promising, because it will eventually allow to use all good opensource CAS systems from python, but our aim is a little different - !SymPy will remain as a simple (but powerful) Python module for symbolic manipulation and the stress is not on a speed, but on a simplicity and versatility.

The code is still in development, but it's already quite useful - for
example, we believe this is the shortest (in terms of lines) open source
code for computing symbolic limits.

==Usage==

Example in the python interpreter:

{{{
>>> from sympy import Symbol, cos
>>> x=Symbol('x')
>>> e=1/cos(x)
>>> print e.series(x,10)
1+1/2*x^2+5/24*x^4+61/720*x^6+277/8064*x^8+50521/3628800*x^10
}}}

There is a nice console `isympy` (in the `bin` directory, or if you installed the `deb`, it will be in `/usr/bin/isympy`) which just imports sympy and defines symbols x,y,z for you, so the above thing can be achieved by starting `isympy` and typing this one line:
{{{
(1/cos(x)).series(x,10)
}}}

To fire you up, here is a piece of code that defines the function cos:

{{{
class cos(Function):
    '''Return the cosine of x (measured in radians)
    '''

    def derivative(self):
        return -sin(self.arg)

    def eval(self):
        if self.arg == 0:
            return Rational(1)
        if self.arg == pi:
            return -Rational(1)
        if self.arg == 2*pi:
            return Rational(1)
        return self
}}}

That's all - now it can be normally used, for instance in the series
expansion, as in the first example. It can differentiate itself and
can evaluate cos(0) and cos(2*pi) to 1, cos(pi) to -1. More complex behaviour (like cos(n*2*pi)=1) can of course be implemented (it actually already is in !SymPy), it's easy.

Read the [http://code.google.com/p/sympy/wiki/Tutorial tutorial] for more examples.


==Development==

You are welcomed to join the development. If you find a bug or just want to say what you think, tell us on the [http://groups.google.com/group/sympy mailinglist]. We are interested in your opinions if you think the !SymPy's interface is not
as you would expect or if you created some algorithm using !SymPy and would like it to become part of !SymPy (so that others can easily use your code as well).

More information can be found in SympyDevelopment.