#summary Documentation for sympy-research branch of sympy.
#labels Phase-Design,Featured

= Introduction =

This page collects documentation notes for the sympy-research branch of sympy.
More information can be found in 
[http://code.google.com/p/sympy/issues/detail?id=144 Issue 144]

Checkout using:
{{{
svn co http://sympy.googlecode.com/svn/branches/sympy-research
}}}

= Mathematical constants =

The following mathematical constants are defined in `sympy`:

 * I --- imaginary unit `sqrt(-1)`
 * oo --- positive infinity
 * nan --- undefined value
 * pi --- pi = 3.14..
 * E, exp(1)  --- Euler number E = 2.718.., exp(1)

Use `.evalf()` method to get floating point approximation with the current precision `Basic.set_precision()`.

== Examples ==

{{{
>>> Basic.set_precision()
28
>>> pi.evalf(), E.evalf()
(3.141592653589793238462643383, 2.718281828459045235360287471)
>>> Basic.set_precision(40)
28
>>> pi.evalf(), E.evalf()
(3.141592653589793238462643383279502884197,
 2.718281828459045235360287471352662497757)
>>> I,I**2,oo,nan
(I, -1, oo, nan)
}}}

= Assigning properties to symbols and expressions =

== Method call ==

  `<expr>.assume(property1=value1, property2=value2, ..)`

== Method parameters ==

  * `property1, ...` --- names of mathematical properties
  * `value1, ...` --- `True` or `False` or `None`

== Details ==

  * The following predefined mathematical propeties are supported:

    # `positive`, `negative` --- `expr` can have only positive or negative real values, respectively
    # `real` --- `expr` can have values from the set of real numbers
    # `integer` --- `expr` can have values from the set of integers
    # `even`, `odd` --- `expr` value is an even or odd integer, respectively 
    # `irrational` --- `expr` value is irrational
    # `bounded` --- `expr` absolute value is bounded
    # `unbounded` --- `expr` value is arbitrarily large
    # `infinitesimal` --- `expr` value is infinitesimal
    # `commutative` --- `expr` value commutes with other values with respect to multiplication
    # `noncommutative` --- `expr` value does not commute with other values with respect to multiplication
    # `comparable` --- `expr` value can be compared with numbers (`expr.evalf()` returns `Number` object).

  * If property value is `False`, the opposite property is set. For example, setting `positive=False` is equivalent to `negative=True`.

  * Assigned properties can be unset using property value `None`.

  * Unsetting a property will unset related properties. For example, unsetting `positive` will also unset `negative` property.

  * `expr` properties can be requested via `.is_property` attributes. If no information is known for a given property then `.is_property` attribute is `None`.

  * `expr` properties can be set using `property=value` keyword arguments in the corresponding class constructor.

== Rules ==

From a set of properties on can derive more properties. For example, if
an expression has property `positive` then it follows that the expression
has also a property being `real` (as the set of positive numbers is a subset of
real numbers) as well as being `complex` (as the set of real numbers
is a subset of complex numbers), etc. In general, a property, say _P_,
may be a union of subproperties, say _P_^1^, _P_^2^, etc. For example, if
_P_ is `real` then _P_^1^ and _P_^2^ can be `positive` and `nonpositive`, respectively.

The following rules apply for derived properties:

  * if `x` has _P_^i^ set to `True`, then _P_ is `True`. Also, _P_^j^ are `None` for all j not equal to i (provided that subproperties have empty intersections).
  * if `x` has _P_^i^ set to `False`, then _P_ is `True` (because `x` must have _P_^j^ set to `True` for some j not equal to i). Also, when there are exactly two subproperties, then _P_^i^ is `True`, otherwise `None`.
  * if `x` has _P_^i^ set to `None` (undefined or when unsetting), then _P_ is `None` only if _P_ was derived from _P_^i^. Also all other _P_^j^ are `None`s.
  * if `x` has _P_ set to `True` then _P_^i^ is `None` (undefined)
  * if `x` has _P_ set to `False` then _P_^i^ is `False` for all i.
  * if `x` has _P_ set to `None` then _P_^i^ is `None` for all i.

== Examples ==

{{{
>>> x = Symbol('x')
>>> x.is_real
>>> x.assume(positive=True)
>>> x.is_real
True
>>> x.is_negative
False
>>> exp(x).is_positive
True
>>> log(x).is_negative
>>> x.assume(infinitesimal=True)
>>> log(x).is_negative
True
>>> y = Symbol('y', even=True)
>>> y.is_integer
True
>>> y.is_odd
False
}}}

= O â€“ the domain of order terms (Landau symbols) =

  `O(f, x)` represents the Landau symbol _O(f, x -> 0)_.

== Call ==

  `O(f, x, y, ..)`

== Parameters ==

  * `f` --- an arithmetical expression representing a function in x, y, etc.
  * `x, y` --- variables, assumed to be infinitesimal and positive symbols

== Return value ==

  an `O` or `Zero` instance.

== Details ==

 * According to the mathematical definition, for a function f with variables x,y, .., the  Landau symbol _g = O(f, x, y, ..)_ is a representative of a class of functions having the following property: there exists a constant M and a neighborhood of the limit point _(0, 0, ..)_ such that _|g| <= M|f|_ for all values _(x,y,..)_ in that neighborhood. Note that in general `O(f(x,y),x,y) + O(g(x,y),x,y)` is not the same as `O(f(x,y)+g(x,y), x,y)`.

 * If variables `x, y, ..` are not specified then all symbols in `f` are considered as order variables. Otherwise all other symbols in `f` except `x, y, ..` are considered as parameters.

 * The symbols in `O` instance can be accessed via `.symbols` attribute.

 * The expression in `O` instance can be accessed via `.expr` attribute.

 * The inclusion relation between _O(f, x)_ and _O(g, x)_ is determined by the result of `limit(f/g, x, 0)`. If the result is unbounded (e.g. `oo`) then _O(g, x)_ is a subset of _O(f, x)_ and `O(f,x)+O(g,x)` results `O(f,x)`.

 * Automatic simplification is applied to `O` expression. See examples.

 * Assumptions `infinitesimal=True, positive=True` are set to `O` symbols.

 * Using `O` in the argument expression of a function leads to either Add or Order instance after applying the rule: _f(g(x) + O(h(x),x)) -> f(g(x)) + O(h(x) f'(g(x)), x)_ provided that _f'(g(x))_ is not zero.

== Examples ==

{{{
>>> from sympy.core import *
>>> x,y=Symbol('x'), Symbol('y')
>>> O(x,x),O(3*x,x),O(x+x**2),O(x+1/x),O(x+1/x+exp(2/x))
(O(x, x), O(x, x), O(x, x), O(1 / x, x), O(exp(2 / x), x))
>>> O(x+3*y), O(x+x*y), O(3*x*y**2-x**2*y+x**2*y**2), O(y**2*x**2+x*y**3,y)
(O(x + y, x, y), O(x, x), O(x * y ** 2 + y * x ** 2, x, y), O(y ** 2, y))
>>> O(x*y).expr, O(x*y).symbols
(x * y, (x, y))
>>> O(0,x), O(2,x)
(0, O(1))
>>> O(x) + O(y), O(x+y)
(O(x, x) + O(y, y), O(x + y, x, y))
>>> exp(1+x+O(x**3))
exp(1 + x) + O(x ** 3, x)
>>> cos(O(x))
1 + O(x ** 2, x)
}}}

= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages





