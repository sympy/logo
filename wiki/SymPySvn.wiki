#summary Documentation to the svn version of SymPy

= Introduction =

As of September 25, we have changed how functions are implemented in !SymPy again. This page serves as a reference, how to work with them. Please discuss new and current features in the [http://code.google.com/p/sympy/issues/detail?id=387 issue 387].

= TODO =

The following functions need yet to be migrated:
{{{
combinatorial/numbers.py:class Fibonacci(DefinedFunction):
combinatorial/numbers.py:class Lucas(DefinedFunction):
combinatorial/numbers.py:class Bernoulli(DefinedFunction):
combinatorial/numbers.py:class Bell(DefinedFunction):
combinatorial/numbers.py:class Harmonic(DefinedFunction):
combinatorial/factorials.py:class Factorial(DefinedFunction):
combinatorial/factorials.py:class MultiFactorial(DefinedFunction):
combinatorial/factorials.py:class RisingFactorial(DefinedFunction):
combinatorial/factorials.py:class FallingFactorial(DefinedFunction):
combinatorial/factorials.py:class Binomial(DefinedFunction):
elementary/integers.py:class Floor(DefinedFunction):
elementary/integers.py:class Ceiling(DefinedFunction):
elementary/hyperbolic.py:class Sinh(DefinedFunction):
elementary/hyperbolic.py:class Cosh(DefinedFunction):
elementary/hyperbolic.py:class Tanh(DefinedFunction):
elementary/hyperbolic.py:class Coth(DefinedFunction):
elementary/hyperbolic.py:class ASinh(DefinedFunction):
elementary/hyperbolic.py:class ACosh(DefinedFunction):
elementary/hyperbolic.py:class ATanh(DefinedFunction):
elementary/hyperbolic.py:class ACoth(DefinedFunction):
special/gamma_functions.py:class Gamma(DefinedFunction):
special/gamma_functions.py:class LowerGamma(DefinedFunction):
special/gamma_functions.py:class UpperGamma(DefinedFunction):
special/gamma_functions.py:class PolyGamma(DefinedFunction):
special/gamma_functions.py:class LogGamma(DefinedFunction):
special/zeta_functions.py:class Zeta(DefinedFunction):
special/zeta_functions.py:class DirichletEta(DefinedFunction): # TBD
special/polynomials.py:class PolynomialSequence(DefinedFunction):
special/polynomials.py:class ChebyshevT_Root(DefinedFunction):
special/polynomials.py:class ChebyshevU_Root(DefinedFunction):
special/error_functions.py:class Erf(DefinedFunction):
}}}

= Functions =

How to create a new function:
{{{
class sign(SingleValuedFunction):

    nofargs = 1

    @classmethod
    def _eval_apply(self, arg):
        if isinstance(arg, Basic.NaN):
            return S.NaN
        if isinstance(arg, Basic.Zero): return S.One
        if arg.is_positive: return S.One
        if arg.is_negative: return S.NegativeOne
        if isinstance(arg, Basic.Mul):
            coeff, terms = arg.as_coeff_terms()
            if not isinstance(coeff, Basic.One):
                return self(coeff) * self(Basic.Mul(*terms))

    is_bounded = True

    def _eval_conjugate(self):
        return self

    def _eval_is_zero(self):
        return isinstance(self[0], Basic.Zero)
}}}

and that's it. The `_eval_*` functions are called when something is needed. The applied function `sign(x)` is constructed using
{{{
sign(x)
}}}
both inside and outside of !SymPy. Unapplied functions `sign` is just the class:
{{{
sign
}}}
Both inside and outside of !SymPy. 

== common tasks ==

Please use the same way as is show below all across !SymPy.

=== accessing parameters ===
{{{
In [1]: e = sign(x**2)

In [2]: e[:]
Out[2]: (x**2,)

In [3]: e[0]
Out[3]: x**2

In [4]: (x+y*z)[:]
Out[4]: (x, y*z)

In [5]: (y*z)[:]
Out[5]: (y, z)

In [6]: sin(y*z)[:]
Out[6]: (y*z,)

}}}
Never use internal methods or variables, prefixed with "`_`" (example: don't use `_args`, use `[:]` instead).

=== testing the structure of a !SymPy expression == 

Applied functions:
{{{ 
In [1]: e = sign(x**2)

In [4]: isinstance(e, sign)
Out[4]: True

In [5]: isinstance(e, exp)
Out[5]: False
}}}
So `e` is a `sign(z)` function, but not `exp(z)` function. 

Unapplied functions:
{{{
In [1]: e = sign

In [2]: f = exp

In [3]: g = Add

In [4]: isinstance(e, FunctionClass)
Out[4]: True

In [5]: isinstance(f, FunctionClass)
Out[5]: True

In [6]: isinstance(g, FunctionClass)
Out[6]: False

In [10]: g is Add
Out[10]: True
}}}
So `e` and `f` are functions, `g` is not a function.
 
 
 