#summary Documentation to the svn version of SymPy

= Introduction =

As of September 25, we changed how functions are done in !SymPy again.

= Functions =

How to create a new function:
{{{
class sign(SingleValuedFunction):

    nofargs = 1

    @classmethod
    def _eval_apply(self, arg):
        if isinstance(arg, Basic.NaN):
            return S.NaN
        if isinstance(arg, Basic.Zero): return S.One
        if arg.is_positive: return S.One
        if arg.is_negative: return S.NegativeOne
        if isinstance(arg, Basic.Mul):
            coeff, terms = arg.as_coeff_terms()
            if not isinstance(coeff, Basic.One):
                return self(coeff) * self(Basic.Mul(*terms))

    is_bounded = True

    def _eval_conjugate(self):
        return self

    def _eval_is_zero(self):
        return isinstance(self[0], Basic.Zero)
}}}

and that's it. The `_eval_*` functions are called when something is needed. The applied function `sign(x)` is constructed using
{{{
sign(x)
}}}
both inside and outside of !SymPy. Unapplied functions `sign` is just the class:
{{{
sign
}}}
Both inside and outside of !SymPy. 

== common tasks ==

Please use the same way as is show below all across !SymPy.

=== accessing parameters ===
{{{
e = sign(x**2)
In [1]: e = sign(x**2)

In [2]: e[:]
Out[2]: (x**2,)

In [3]: e[0]
Out[3]: x**2
}}}
Never use internal methods or variables, prefixed with "_" (like `_args` -- don't use it).
 
 