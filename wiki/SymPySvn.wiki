#summary Documentation to the svn version of SymPy

= Introduction =

As of September 25, we changed how functions are done in !SymPy again.

= Functions =

How to create a new function:
{{{
class sign(SingleValuedFunction):

    nofargs = 1

    @classmethod
    def _eval_apply(self, arg):
        if isinstance(arg, Basic.NaN):
            return S.NaN
        if isinstance(arg, Basic.Zero): return S.One
        if arg.is_positive: return S.One
        if arg.is_negative: return S.NegativeOne
        if isinstance(arg, Basic.Mul):
            coeff, terms = arg.as_coeff_terms()
            if not isinstance(coeff, Basic.One):
                return self(coeff) * self(Basic.Mul(*terms))

    is_bounded = True

    def _eval_conjugate(self):
        return self

    def _eval_is_zero(self):
        return isinstance(self[0], Basic.Zero)
}}}

and that's it. The `_eval_*` functions are called when something is needed. The applied function `sign(x)` is constructed using
{{{
sign(x)
}}}
both inside and outside of !SymPy. Unapplied functions `sign` is just the class:
{{{
sign
}}}
Both inside and outside of !SymPy. 

== common tasks ==

Please use the same way as is show below all across !SymPy.

=== accessing parameters ===
{{{
In [1]: e = sign(x**2)

In [2]: e[:]
Out[2]: (x**2,)

In [3]: e[0]
Out[3]: x**2
}}}
Never use internal methods or variables, prefixed with "`_`" (like `_args` -- don't use it -- use `[:]` instead).

=== testing the structure of !SymPy expression == 

Applied functions:
{{{ 
In [1]: e = sign(x**2)

In [4]: isinstance(e, sign)
Out[4]: True

In [5]: isinstance(e, exp)
Out[5]: False
}}}
So `e` is a `sign(z)` function, but not `exp(z)` function. 

Unapplied functions:
{{{
In [1]: e = sign

In [2]: f = exp

In [3]: g = Add

In [4]: isinstance(e, FunctionClass)
Out[4]: True

In [5]: isinstance(f, FunctionClass)
Out[5]: True

In [6]: isinstance(g, FunctionClass)
Out[6]: False

In [10]: g is Add
Out[10]: True
}}}
So `e` and `f` are functions, `g` is not a function.